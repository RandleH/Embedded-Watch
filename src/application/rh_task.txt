/**
  ******************************************************************************
  * @file    task.cc
  * @author  RandleH
  * @brief   This file contains code template.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 RandleH.
  * All rights reserved.
  *
  * This software component is licensed by RandleH under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"

#include "lvgl.h"

#include "rh_debug.h"
#include "rh_light.h"
#include "rh_screen.h"




/* Private define ------------------------------------------------------------*/
#define RH_STATIC        // static



/* Private functions ---------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif

RH_STATIC void task_dy__ui_helloworld( void* ){
    /*Change the active screen's background color*/
    lv_obj_set_style_bg_color(lv_scr_act(), lv_color_hex(0x003a57), LV_PART_MAIN);

    /*Create a white label, set its text and align it to the center*/
    lv_obj_t * label = lv_label_create(lv_scr_act());
    lv_label_set_text(label, "Hello world");
    lv_obj_set_style_text_color(lv_scr_act(), lv_color_hex(0xffffff), LV_PART_MAIN);
    lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);

    while(1){
        //...//
    }
}




/*====================================================================
 * FreeRTOS空闲任务配置
=====================================================================*/
static StaticTask_t   Idle_Task_TCB;
static StackType_t    Idle_Task_Stack[configMINIMAL_STACK_SIZE];
void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t  ** ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize   ){
    *ppxIdleTaskTCBBuffer    = &Idle_Task_TCB;             /* 任务控制块内存 */ 
    *ppxIdleTaskStackBuffer  = Idle_Task_Stack;            /* 任务堆栈内存 */ 
    *pulIdleTaskStackSize    = configMINIMAL_STACK_SIZE;   /* 任务堆栈大小 */
}


/*====================================================================
 * FreeRTOS定时器任务配置
=====================================================================*/
static StaticTask_t   Timer_Task_TCB;
static StackType_t    Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH];
void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer, StackType_t  ** ppxTimerTaskStackBuffer, uint32_t * pulTimerTaskStackSize  ){
    *ppxTimerTaskTCBBuffer    = &Timer_Task_TCB;             /* 任务控制块内存 */ 
    *ppxTimerTaskStackBuffer  = Timer_Task_Stack;            /* 任务堆栈内存 */ 
    *pulTimerTaskStackSize    = configMINIMAL_STACK_SIZE;    /* 任务堆栈大小 */
}







/**
 * @category System::Task::UI:: flush
 * @brief    Flush a screen within a fixed time interval. 
 * @param    Repeat:      10ms.
 * @param    Stack_Size:  256 bytes
 * @param    Priority:    3
 * @include  `freertos`  `lvgl`
*/
RH_STATIC void task_sta__ui_flush( void* ){
    static TickType_t xLastWakeTime = xTaskGetTickCount();
    
    while(1){    
        lv_timer_handler();
    
        vTaskDelayUntil( &xLastWakeTime, 10U);

        lv_tick_inc(10);
    }
}
static StackType_t  stbuf__ui_flush[256];
static StaticTask_t tcb__ui_flash;
static TaskHandle_t handle__ui_flash;
#define SETTING_sta__ui_flush      "ui-flush", 256, NULL, 3, stbuf__ui_flush, &tcb__ui_flash


/**
 * @category System::Task::CTRL:: led
 * @brief    LED heart beat.
 * @param    Repeat:      1000ms.
 * @param    Stack_Size:  64 bytes
 * @param    Priority:    4
 * @include  `freertos`  
*/
RH_STATIC void task_sta__ctrl_led( void* ){
    
    while(1){    
        rh_light__toggle( RH_LED_IDX__BLUE);
        vTaskDelay(1000U);
    }
}
static StackType_t  stbuf__ctrl_led[64];
static StaticTask_t tcb__ctrl_led;
static TaskHandle_t handle__ctrl_led;
#define SETTING_sta__ctrl_led      "ctrl-led", 64, NULL, 4, stbuf__ctrl_led, &tcb__ctrl_led









#include "stm32f4xx.h"
#include "core_cm4.h"









lv_obj_t *ui_Screen1;
lv_obj_t *ui_Switch2;
lv_obj_t *ui_Colorwheel2;

void ui_Screen1_screen_init(void){
    ui_Screen1 = lv_obj_create(NULL);
    lv_obj_clear_flag( ui_Screen1, LV_OBJ_FLAG_SCROLLABLE );    /// Flags
    lv_obj_set_style_bg_color(ui_Screen1, lv_color_hex(0x5A5A5A), LV_PART_MAIN | LV_STATE_DEFAULT );
    lv_obj_set_style_bg_opa(ui_Screen1, 255, LV_PART_MAIN| LV_STATE_DEFAULT);

    ui_Switch2 = lv_switch_create(ui_Screen1);
    lv_obj_set_width( ui_Switch2, 50);
    lv_obj_set_height( ui_Switch2, 25);
    lv_obj_set_x( ui_Switch2, 2 );
    lv_obj_set_y( ui_Switch2, -9 );
    lv_obj_set_align( ui_Switch2, LV_ALIGN_CENTER );
    lv_obj_set_style_bg_color(ui_Switch2, lv_color_hex(0x787878), LV_PART_MAIN | LV_STATE_DEFAULT );
    lv_obj_set_style_bg_opa(ui_Switch2, 255, LV_PART_MAIN| LV_STATE_DEFAULT);

    ui_Colorwheel2 = lv_colorwheel_create(ui_Screen1,true);
    lv_obj_set_width( ui_Colorwheel2, 150);
    lv_obj_set_height( ui_Colorwheel2, 150);
    lv_obj_set_align( ui_Colorwheel2, LV_ALIGN_CENTER );

}

void ui_init( void ){
    lv_disp_t *dispp = lv_disp_get_default();
    lv_theme_t *theme = lv_theme_default_init(dispp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED), false, LV_FONT_DEFAULT);
    lv_disp_set_theme(dispp, theme);
    ui_Screen1_screen_init();
    lv_disp_load_scr( ui_Screen1);
}

bool bsp_init__flag = false;


/**
 * @category System::Task::BSP:: init
 * @brief    Flush a screen within a fixed time interval. 
 * @include  `freertos`  
 * @details  - Repeat:      never
 *           - Stack size:  128 bytes
 *           - Priority:    3
*/
RH_STATIC void task_dy__bsp_init( void* ){
    rh_light__init();
    rhlv_screen__init();
    rh_screen__init();
    
    ui_init();


    bsp_init__flag = true;

    // vTaskDelete(NULL);
    // while(1);
}

/**
 * @category System::Task::BSP:: init
 * @brief    Flush a screen within a fixed time interval. 
 * @include  `freertos`  
 * @details  - Repeat:      never
 *           - Stack size:  128 bytes
 *           - Priority:    3
*/
RH_STATIC void task_dy__app_init( void* ){
    
    while(1){

        if( bsp_init__flag){
            handle__ui_flash = xTaskCreateStatic( task_sta__ui_flush, SETTING_sta__ui_flush);
            handle__ctrl_led = xTaskCreateStatic( task_sta__ctrl_led, SETTING_sta__ctrl_led);
            vTaskDelete(NULL);
        }else{
            vTaskDelay(100);
        }

    }
}



int rh_task__init( void ){
    NVIC_SetPriorityGrouping( 4 );
    xTaskCreate( task_dy__bsp_init, NULL, 512, NULL, 1U, NULL);
    xTaskCreate( task_dy__app_init, NULL, 512, NULL, 1U, NULL);


    return 0;
}

int rh_task__start( void){
    vTaskStartScheduler();
    return 0;
}

#ifdef __cplusplus
}
#endif













